# 제 10강 피연산자 
## 1. 피연산자(operand) 개요
- 연산자의 정의된 연산을 하기 위하여 사용되는 레지스터나 상수, 레이블, 메모리주소 등을 뜻하는 말.
- 레지스터는 데이터를 저장하는 장치중 속도나 가장 빠른 장소이므로 일부 레지스터만 사용 가능. 
- 더 적은 레지스터를 필요로 하는 순서로 연산을 함으로써 더 많은 피연산자를 레지스터에 할당할 수 있게 된다. 

## 2. 피연산자 데이터 단위 
| 데이터 단위 | 크기 |
|---|:---:|
| word | 32bit |
| half word | 16bit |
| byte | 8bit |

- MIPS 명령어(instruction) 및 레지스터는 **32비트**로 구성되어 있음 

## 2-1. 연습문제 1 
- $s0 = F, $s1 = G, $s2 = H,, $s3 = I, $s4 = J
- F = (G + H) - (I + J); <br>
-> (MIPS) <br> 
-> 여기서 $t는 변수로 사용됨 <br>
-> add $t0, $t1, $t2 # t0 = g+h, s1 = g, s2 = h <br>
-> add $t1, $s3, $s4 # t1 = i+j, s3 = i, s4 = j  <br>
-> sub $s0, $t0, $t1 # s0 = f, t0 = g+h, t1 = i+j

## 3. 메모리 피연산자 
- 프로그래밍 언어에는 단순 변수가 아닌 자료형이 존재(ex. 구조체, 배열)
- 레지스터는 소량의 데이터만 저장할 수 있기 때문에 나머지 데이터는 메모리(Heap, Stack)에 저장 후 주소에 접근하여 사용함 
- 메모리에서 **Heap**은 동적으로 할당되는 변수가 저장되는 공간, **Stack**은 정적으로 할당되는 변수가 저장되는 공간 (배열을 하나 선언했다고 하면 Stack공간에 선언이 될 것이다)
- 메모리와 레지스터간 데이터를 주고받는 명령어를 **데이터 전송 명령어(Data Transfer Instruction)** 라고함 (메모리 <-> 레지스터)

## 4. 적재 명령어(메모리에 있는 값을 레지스터로 불러오는 것)
- 메모리는 주소가 인덱스의 역할을 하는 일차원 구조 
- 메모리에서 레지스터로 데이터를 복사해 오는 데이터 전송 명령어를 적재(Load)라고 함 
- 적재 명령어는 연산자(lw) + 값을 저장할 레지스터 + 메모리 접ㄱ느에 사용할 상수 및 레지스터로 구성됨 
- 4($s3) == [Memory address + 4]

ex) 메모리의 시작주소가 **$s3**라고 가정할 때,

| address | data | 표기 |
|---|:---:|:---:|
| 0x000C | 3 | 12($s3) |
| 0x0008 | 2 | 8($s3) |
| 0x0004 | 3 | 4($s3) |
| 0x0000 | 5 | ($s3) | 
-> register

## 4-1. 연습문제 2 
다음 문장을 MIPS 명령어로 치환하여라. <br>
 g = h + A[1];
 - g,h는 각각 $s1, $s2에 할당 
 - 배열 A의 시작주소는 $s3에 할당 

 lw $t0, 4($s3) # $t0 = Memory[$s3 + 4]
 add $s1, $s2, $t0 # $s1 = $s2 + $t0 
 - 데이터 전송명령어 상수 부분(4)를 offset이라고 함
 - 자료구조의 시작주소를 가리키는 레지스터를 Base register라고 함
 - MIPS에서 시작주소는 항상 4의 배수여야 한다(정렬 제약) - word가 4의 배수로 저장되어 있기 때문에

## 5. 저장 명령어 
- 적재와 반대로 레지스터에서 메모리로 데이터를 보내는 명령을 저장(store)라고 함 
- 적재 명령어와 같은 구조 
- 연산자(sw) + 저장할 데이터를 가진 레지스터 + 메모리 주소 레지스터 및 상수(offset)의 조합 

## 5-1. 연습문제 3

| address | data | 표기 |
|---|:---:|:---:|
| 0x000C | 3 | 12($s3) |
| 0x0008 | 2 | 8($s3) |
| 0x0004 | 3 | 4($s3) |
| 0x0000 | 5 | ($s3) | 

다음 MIPS 명령어를 C언어로 치환하여라. 

lw $t0, 8($s3) <br>
add $t0, $s1, $t0 <br>
sw $t0, 32($s3) <br>

- h는 $s1에 할당 
- 배열 A의 시작주소는 $s3에 할당 

**풀이** <br>
lw $t0, 8($s3) -> A[2]를 메모리에서 레지스터로 가져옴 <br>
add $t0, $s1, $t0 ->  h 변수에 A[2]를 더함 <br>
sw $t0, 32($s3) -> 연산된 값을 A[8]에 저장 <br>

#### 답: A[8] = h + A[2]
- 배열 A의 인덱스 2에 접근하기 위해서는 2*4 = 8을 $s3에 더해야함 
- 배열 A의 인덱스 2의 값을 임시 레지스터 t0에 저장 
- $s1에 저장된 h의 값과 add 연산 
- sw 연산을 이용하여 A[8]에 값을 저장하기 위해서는 베이스 레지스터에 8*4 = 32의 값을 더해야함 

## 6. 수치연산 
- 프로그램 연산에서 레지스터가 아닌 상수를 사용하는 경우 
- 상수 필드를 갖는 산술 명령어를 사용시 메모리에서 적재하는 것보다 효율적 
- 사용빈도가 높으면 상수를 명령어에 포함하는 것이 좋음(Common case fast) 
- 연산자: addi(add와 같은 구조)

