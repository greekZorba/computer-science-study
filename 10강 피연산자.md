# 제 10강 피연산자 
## 1. 피연산자(operand) 개요
- 연산자의 정의된 연산을 하기 위하여 사용되는 레지스터나 상수, 레이블, 메모리주소 등을 뜻하는 말.
- 레지스터는 데이터를 저장하는 장치중 속도나 가장 빠른 장소이므로 일부 레지스터만 사용 가능. 
- 더 적은 레지스터를 필요로 하는 순서로 연산을 함으로써 더 많은 피연산자를 레지스터에 할당할 수 있게 된다. 

## 2. 피연산자 데이터 단위 
| 데이터 단위 | 크기 |
|---|:---:|
| word | 32bit |
| half word | 16bit |
| byte | 8bit |

- MIPS 명령어(instruction) 및 레지스터는 **32비트**로 구성되어 있음 

## 3. 연습문제 1 
- $s0 = F, $s1 = G, $s2 = H,, $s3 = I, $s4 = J
- F = (G + H) - (I + J); <br>
-> (MIPS) <br> 
-> 여기서 $t는 변수로 사용됨 <br>
-> add $t0, $t1, $t2 # t0 = g+h, s1 = g, s2 = h <br>
-> add $t1, $s3, $s4 # t1 = i+j, s3 = i, s4 = j  <br>
-> sub $s0, $t0, $t1 # s0 = f, t0 = g+h, t1 = i+j

## 4. 메모리 피연산자 
- 프로그래밍 언어에는 단순 변수가 아닌 자료형이 존재(ex. 구조체, 배열)
- 레지스터는 소량의 데이터만 저장할 수 있기 때문에 나머지 데이터는 메모리(Heap, Stack)에 저장 후 주소에 접근하여 사용함 
- 메모리에서 **Heap**은 동적으로 할당되는 변수가 저장되는 공간, **Stack**은 정적으로 할당되는 변수가 저장되는 공간 (배열을 하나 선언했다고 하면 Stack공간에 선언이 될 것이다)
- 메모리와 레지스터간 데이터를 주고받는 명령어를 **데이터 전송 명령어(Data Transfer Instruction)**라고함 (메모리 <-> 레지스터)

## 5. 적재 명령어(메모리에 있는 값을 레지스터로 불러오는 것)
- 메모리는 주소가 인덱스의 역할을 하는 일차원 구조 
- 메모리에서 레지스터로 데이터를 복사해 오는 데이터 전송 명령어를 적재(Load)라고 함 
- 적재 명령어는 연산자(lw) + 값을 저장할 레지스터 + 메모리 접ㄱ느에 사용할 상수 및 레지스터로 구성됨 
- 4($s3) == [Memory address + 4]

ex) 메모리의 시작주소가 **$s3**라고 가정할 때,

| address | data | 표기 |
|---|:---:|:---:|
| 0x000C | 3 | 12($s3) |
| 0x0008 | 2 | 8($s3) |
| 0x0004 | 3 | 4($s3) |
| 0x0000 | 5 | ($s3) | 
-> register

## 6. 연습문제 2 
다음 문장을 MIPS 명령어로 치환하여라. <br>
 g = h + A[1];
 - g,h는 각각 $s1, $s2에 할당 
 - 배열 A의 시작주소는 $s3에 할당 

 lw $t0, 4($s3) # $t0 = Memory[$s3 + 4]
 add $s1, $s2, $t0 # $s1 = $s2 + $t0 
 - 데이터 전송명령어 상수 부분(4)를 offset이라고 함
 - 자료구조의 시작주소를 가리키는 레지스터를 Base register라고 함
 - MIPS에서 시작주소는 항상 4의 배수여야 한다(정렬 제약) - word가 4의 배수로 저장되어 있기 때문에


