# 제 16강 주소지정방식 
## 1.1 MIPS 주소지정 방식 
- 수치 주소지정: 피연산자는 명령어 내에 있는 상수 (immediate, 16bit 상수)
- 레지스터 주소지정: 피연산자는 레지스터 
- 베이스 레지스터 주소지정: 메모리 주소는 베이스 레지스터의 값과 주소필드의 변위값을 더해서 구한다.(lw, sw 명령어)
- PC 상대 주소지정: PC값과 명령어 내 상수의 합을 더해서 주소를 구한다. (PC+address, PC->32bit)
- 의사직접 주소지정: 명령어 내의 26비트를 PC의 상위비트들과 연접하여 점프주소를 구한다. 

## 1.2 수치 주소지정
- 명령어의 주소 필드에 데이터가 들어있으며 상수의 정의나 변수 값의 초기화에 편리하다. 
- 데이터를 얻기위한 기억장치 접근이 필요 없으므로 명령어 사이클 한 개가 적음 
- 사용할 수 있는 수의 크기가 주소필드의 크기로 제한됨. <br>
| op | rs | rt | immediate(상수) |

## 1.3 레지스터 주소지정 
- CPU내의 레지스터에 데이터가 저장되어 있는 방식 
- 주소 필드가 레지스터 번호를 나타내므로 적은 비트수가 필요함 
- 데이터 저장공간이 CPU 내부 레지스터로 제한 

## 1.4 베이스레지스터 주소지정 
- 베이스 레지스터의 값과 주소필드의 변위 값을 더해서 주소를 구함 
- 피연산자가 메모리에 존재하고 있음 
- 메모리 자원을 사용하므로 저장형식이 유연함 
- lw $s0, 4($s3) 가 있을 때 4는 offset $s3는 base로 둘을 더해서 주소를 구함 
- 속도: memory < register 

## 1.5 상대 주소 지정 
- PC(Program Counter)의 값에 명령어의 주소 필드의 값(16비트)을 더해서 유효주소를 구하는 방식.
- 적은비트를 사용하는 것으로 32비트 분기주소를 만드는 것이 가능함 
- 조건부 분기명령에 사용됨 

## 1.6 의사 직접 주소 지정 
- 명령어 내의 26비트를 PC의 상위 비트들과 연접하여 점프 주소를 구한다. 
- op(6bit), address(26bit)를 PC명령어에 합치면 32비트 주소 체계를 구할 수 있다. 
- 무조건 분기문에서 주로 사용됨 

## 1.7 32비트 상수 operand
- 프로그램에서 사용하는 상수는 대체로 작은 크기 
- MIPS는 레지스터를 16비트씩 나누어 상수를 저장하는 것이 가능 
- lui(load upper immediate): 레지스터 상위 16비트에 상수를 저장 

