# 제 12강 명령어의 컴퓨터 내부표현 
## 1. 명령어의 해석방법 
- 명령어도 높고 낮은 전기신호의 연속이므로 숫자로 표현하는 것이 가능 
- 레지스터가 명령어에서 참조되기 때문에 레지스터 이름을 숫자로 매핑하는 규칙이 존재 
- $s0~$s7 == 16~23
- $t0~$t7 == 8~15

## 2. 어셈블리어의 기계어 변환 
add $t0, $s1, $s2 <br>
| 6bit | 5bit | 5bit | 5bit | 5bit | 6bit |
|---|:---:|:---:|:---:|:---:|:---:|
| 0 | 17 | 18 | 8 | 0 | 32 |
| op | rs | rt | rd | shamt | funct |

- 명령어의 각 부분을 필드(field)라고 함 
- 위와 같은 형식을 명령어 형식이라고 함 
- 기계어는 보통 16진수를 사용하여 표현함 
<br><br>
- op : 명령어가 실행할 연산의 종류로서 연산자(opcode)로 구분짓는 역할 
- rt : 첫번째 근원지(Source) operand 레지스터 
- rd : 목적지(Destination) 레지스터. 연산결과가 기억됨. 
- shamt : 자리이동(shift)량 
- funct : op 코드에 표시된 연산의 구체적인 종류 지정 

## 3. 명령어 타입 
- R 타입 : 오른쪽 필드가 3개일 경우 
- I 타입 : 오른쪽 절반 필드가 1개일 경우 
- address는 16비트 주소 
- 명령어 형식이 여러가지가 되면 복잡해지지만 유사하게 설계함으로써 복잡도를 낮춤 

## 4. 변환 실습 
A[300] = h + A[300] <br>
-> lw $t0, 1200($s3) <br>
-> add $t0, $s2, $t0 <br>
-> sw $t0, 1200($s3) <br>

## 변환 실습 
lw $t0, 1200($s3) <br>
add $t0, $s2, $t0 <br>
sw $t0, 1200($s3) <br>

| 35 | 19 | 8 | 1200 | <br>
| 0  | 18 | 8 |8|0|32| <br>
| 43 | 19 | 8 | 1200 |